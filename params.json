{
  "name": "Succinc<T>",
  "tagline": "Discriminated unions, pattern matching and functional composition for C#",
  "body": "## Succinc\\<T\\> ##\r\n#### Discriminated unions, pattern matching and partial applications for C#  ####\r\n----------\r\n### Introduction ###\r\nSuccinc\\<T\\> is a small .NET framework that started out as a means of providing an elegant solution to the problem of functions that need return a success state and value, or a failure state. Initially, it consisted of a few `Parse` methods that returned an `ISuccess<T>` result. Then I started learning F#...\r\n\r\nNow Succinc\\<T\\> has grown into a library that provides discriminated unions, pattern matching and partial applications for C#, in addition to providing a set of value parsers that do away with the need for `out` parameters and exceptions, and instead return return an `Option<T>`.\r\n\r\n### Current Release ###\r\nThe current release of Succinc\\<T\\> is 2.0.0, which is [available as a nuget package](https://www.nuget.org/packages/SuccincT/). \r\n\r\nPlease be warned that this release [includes a number of breaking changes. Please consult the documentation before installing](https://github.com/DavidArno/SuccincT/issues/6). \r\n\r\nThis release includes:\r\n* A completely rewritten implementation of pattern matching (keeping the same semantics, so this shouldn't break and existing uses),\r\n* A new `Unit` type and associated methods for converting `Action<T..>` delegates to `Func<T...,Unit>` ones,\r\n* New `Lambda`, `Transform`, `Func` and `Action` methods to simplify the declaration and typing of lambdas.\r\n* A new `Maybe` type, which is a `struct` version of `Option`. This type is largely interchangable with `Option` and is provided for those that (a) prefer the semantics associated with \"maybe\" versus \"option\" and (b) those that prefer the idea of such a type being a `struct` (and those not able to be `null`.\r\n\r\n### Features ###\r\n#### Discriminated Unions ####\r\nSuccinc\\<T\\> provides a set of union types ([`Union<T1, T2>`](https://github.com/DavidArno/SuccincT/wiki/UnionT1T2), [`Union<T1, T2, T3>`](https://github.com/DavidArno/SuccincT/wiki/UnionT1T2T3) and [`Union<T1, T2, T3, T4>`](https://github.com/DavidArno/SuccincT/wiki/UnionT1T2T3T4))  where an instance will hold exactly one value of one of the specified types. In addition, it provides the likes of [`Option<T>`](https://github.com/DavidArno/SuccincT/wiki/Option_T_) and [`Maybe<T>`](https://github.com/DavidArno/SuccincT/wiki/Maybe_T_) that can have the value `Some<T>` or [`None`](https://github.com/DavidArno/SuccincT/wiki/None).\r\n\r\nSuccinc\\<T\\> uses [`Option<T>`](https://github.com/DavidArno/SuccincT/wiki/Option_T_) to provide replacements for the .NET basic types' `TryParse()` methods and `Enum.Parse()`. In all cases, these are extension methods to `string` and they return `Some<T>` on a successful parse and [`None`](https://github.com/DavidArno/SuccincT/wiki/None) when the string is not a valid value for that type. No more `out` parameters! See the [Option Parsers guide](https://github.com/DavidArno/SuccincT/wiki/OptionParsers) for more details.\r\n\r\nFurther Succinc\\<T\\> uses [`Option<T>`](https://github.com/DavidArno/SuccincT/wiki/Option_T_) to [provide replacements for the XxxxOrDefault LINQ extension methods on `IEnumerable<T>`](https://github.com/DavidArno/SuccincT/wiki/IEnumerableExtensions). In all cases, these new extension methods, eg `TryFirst<T>()` return an option with a value if a match occurred, or `None` if not.\r\n\r\n#### Pattern Matching ####\r\nSuccinc\\<T\\> can pattern match values, tuples, unions etc in a way similar to F#'s pattern matching features. It uses a fluent (method chaining) syntax to achieve this. Some examples of its abilities:\r\n\r\n```csharp\r\npublic static void PrintColorName(Color color)\r\n{\r\n    color.Match()\r\n         .With(Color.Red).Do(x => Console.WriteLine(\"Red\"))\r\n         .With(Color.Green).Do(x => Console.WriteLine(\"Green\"))\r\n         .With(Color.Blue).Do(x => Console.WriteLine(\"Blue\"))\r\n         .Exec();\r\n}\r\n\r\npublic static string SinglePositiveOddDigitReporter(Option<int> data)\r\n{\r\n    return data.Match<string>()\r\n               .Some().Of(0).Do(x => \"0 isn't positive or negative\")\r\n               .Some().Where(x => x == 1 || x == 3 || x == 5 || x == 7 || x == 9).Do(x => x.ToString())\r\n               .Some().Where(x => x > 9).Do(x => string.Format(\"{0} isn't 1 digit\", x))\r\n               .Some().Where(x => x < 0).Do(i => string.Format(\"{0} isn't positive\", i))\r\n               .Some().Do(x => string.Format(\"{0} isn't odd\", x))\r\n               .None().Do(() => string.Format(\"There was no value\"))\r\n               .Result();\r\n}\r\n```\r\n\r\nSee the [Succinc\\<T\\> pattern matching guide](https://github.com/DavidArno/SuccincT/wiki/PatternMatching) for more details.\r\n\r\n#### Partial Applications ####\r\nSuccinc\\<T\\> supports partial function applications. A parameter can be supplied to a multi-parameter method and a new function will be returned that takes the remaining parameters. For example:\r\n\r\n```csharp\r\nvar times = Lambda<double>((p1, p2) => p1 * p2);\r\nvar times8 = times.Apply(8);\r\nvar result = times8(9); // <- result == 72\r\n```\r\n\r\nSee the [Succinc\\<T\\> partial applications guide](https://github.com/DavidArno/SuccincT/wiki/PartialFunctionApplications) for more details.\r\n\r\n#### \"Implicitly\" Typed Lambdas ####\r\nC# doesn't support implicitly typed lambdas, meaning it's not possible to declare something like:\r\n```csharp\r\nvar times = (p1, p2) => p1 * p2;\r\n```\r\nNormally, `times` would have to explicitly typed:\r\n```csharp\r\nFunc<double, double, double> times = (p1, p2) => p1 * p2;\r\n```\r\nSuccinc\\<T\\> offers an alternative approach, taking advantage of the fact that `var` can be used if the result of a method is assigned to the variable. Using the `Func`, `Action`, `Transform` and `Lambda` set of methods, the above can be expressed more simply as:\r\n```csharp\r\nvar times = Lambda<double>((p1, p2) => p1 * p2);\r\n```\r\nFor functions, the `Lambda` methods can be used when the parameters and return type all have the same value, as above. This means the type parameter need only be specified once. `Transform` can be used when all the parameters are of one type and the return value, another. The `Func` methods are used when the parameters and/or return type are of different values. For actions, `Lambda` can also be used when only one type is involved and the `Action` methods do a similar job to the `Func` methods. \r\n\r\nThis is explained in detail in the [Succinc\\<T\\> typed lambdas guide](https://github.com/DavidArno/SuccincT/wiki/TypedLambdas).\r\n\r\n#### `Action`/`Func` conversions ####\r\nThe `ToUnitFunc` methods supplied by Succinc\\<T\\> can be used to cast an `Action` lambdas or method (from 0 to 4 parameters) to a `Func` delegate that returns [`unit`](https://github.com/DavidArno/SuccincT/wiki/Unit), allowing `void` methods to be treated as functions and thus eg used in ternary oprators. In addition, Succinc\\<T\\> provides an `Ignore` method that can be used to explicitly ignore the result of any expression, effectively turning that expression into a `void`\r\n\r\nThese methods are explained in detail in the [Succinc\\<T\\> `Action`/`Func` conversions guide](https://github.com/DavidArno/SuccincT/wiki/ActionFuncConversions).\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}